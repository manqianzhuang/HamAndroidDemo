## 设计模式6大原则 1. 单一职责：明确某个类只负责某个业务，不应该掺杂其他类的业务 2. 开闭原则：对拓展开放，对修改关闭。只允许对业务进行拓展而不能改变业务本身的逻辑 3. 迪米特原则： 两个类之间不能够相互参与之间的初始化操作 4. 依赖倒置：用抽象方法代替具体方法 5. 接口隔离：传参时，把抽象对象代替具体对象当做参数传递 6. 里式替换：把子类的共同方式抽象化，用抽象方法代替具体方法------------------------------------------------------------------------## android导致内存泄漏的原因 1. Activity、View定义为static类型，或者在单例中以Activity为参数 2. Handler未使用static修饰 3. 内部类没有添加static关键字 4. 集合类持有未释放的资源 5. 第三方引用SDK时，持有activity对象 6. Listener、BroadcastReceiver、io、cursor等在使用完毕后未释放------------------------------------------------------------------------## Android性能优化 1. 布局优化  a.使用merge、ViewStub标签去优化布局，  b.使用constraintLayout代替relativeLayout，减少页面层级  c.重用布局include 2. 绘制优化，  a. 在onDraw方法中尽量不去创建局部的实例  b. 在onDraw方法中不执行耗时操作 3. 内存泄漏优化：以上已经提到了Android内存泄漏的可能性，尽量避免以上操作 4. Bitmap优化：图片压缩、三级缓存 5. 合理使用软引用和弱引用 6. 尽量使用线程池代替new Thread 7. application尽量减少无需尽早初始化的SDK------------------------------------------------------------------------## 描述Activity, Window，View, ViewRootImpl之间的关系  1.Activity     Activity不参与view的创建，它委托内部的PhoneWindow实现     当Activity创建的时调用attach()方法时，会初始化一个继承于window的PhoneWindow，     它是一个控制器，控制着Window的运转  2. PhoneWindow     它内部含有一个DecorView, DecorView是所有View的根节点，是Android的树状视图的容器     DecorView继承于FrameLayout     它通过addView把setContentView传递过来的页面加载到DecorView里面是  3. DecorView     内部包含一个LinearLayout, LinearLayout里面包含了3个子节点     a. ViewStub-- 状态栏区域     b. 标题栏 -- android自带的标题栏     c. 内容区域 -- setContentView添加的布局  4. ViewRoot     它是连接WindowsManagerService和DecorView的纽带，     它的实现类的ViewRootImpl     它控制view的measure、layout、draw的方法------------------------------------------------------------------------## Fragment的生命周期  onAttach->onCreate->onCreateView->onActivityCreated->  onStart->onResume->onPause->onStop->onDestroyView->  onDestroy->onDetach------------------------------------------------------------------------## 图片压缩（BitmapFactory）  1. 初始化BitmapFactory.options  2. 设置options.inJustDecodeBounds = true  3. BitmapFactory.decode()，加载原图片  4. 计算图片大小, calculateInSampleSize(options)  5. 设置options.inJustDecodeBounds = false  6. BitmapFactory.decode()，加载压缩后的图片------------------------------------------------------------------------## ArrayList和LinkedList的区别  ArrayList:    1. 数组形式实现    2. 自动扩容    3. 性能好，节省空间    4. 查询效率高  LinkedList:    1. 双链表实现    2. 没有大小限制    3. 前后区间查询    4. 增加、删除效率高------------------------------------------------------------------------## HashMap与HashSet的区别   1. HashMap可以存在重复值，HashSet不允许集合中存在重复的值   2. HashMap储存键值对，HashSet只储存对象   3. HashMap实现Map接口, HashSet实现Set接口   4. HashMap通过put方法添加对象，HashSet通过add添加对象   5. HashMap效果高，他是通过唯一的key值查询，HashSet查询效率慢------------------------------------------------------------------------## Android动画  1. 帧动画    由一帧一帧的图片组成，用xml实现效果。  2. 补间动画    a. 包含scale、alpha、translate、rotation等动画效果，用xml可实现组合效果。    b. 它不改变view的大小、透明度、位置。  3. 属性动画    a. 包含scale、alpha、translate、rotation等动画效果    b. 它改变view的属性，包括大小、位置、透明度    c. 它使用ValueAnimator和ObjectAnimator实现动画    d. 插值器：https://blog.csdn.net/ToBeTheOnlyOne/article/details/79617878------------------------------------------------------------------------## Android进程优先级  1. 前台进程、服务进程  2. 可见的后台进程  3. 不可见的后台进程  4. 空进程------------------------------------------------------------------------## java线程的状态 1. 初始化状态，new Thread() 2. 运行状态，running 3. 阻塞状态 4. 超时状态 5. 异常超时状态 6. 结束状态，线程执行完毕后，不能再次调用此Thread实例，否则抛异常------------------------------------------------------------------------## Handler消息机制 1. Handler是线程之间传递信息的桥梁 2. 创建Handler，创建Looper，创建MessageQueue（MessageQueue是一个链接结构）， 3. Looper.loop，创建for无条件循环，调用queue.next()获取消息对象 4. handler.sendMessage的时候，最终会调用handler的sendMessageAtTime,    然后调用messageQueue把message对象入栈，经过校验后把message抛给handleMessage回调函数，------------------------------------------------------------------------## View的绘制原理  DecorView --> ViewGroup(-->ViewGroup) --> View  View/ViewGroup都会执行onMeasure和onDraw方法  每个ViewGroup都会执行onLayout方法, View无需执行  Measure测量流程：    measure() --> onMeasure(widthModeSpec, heightModeSpec) --> setMeasureDimension()  MeasureSpecMode（绘制模式）:    UNSPECIFIED: view需要多大的宽高度，就给多的宽高度，一般用于系统    EXACTLY: 对应MATCH_PARENT，或者固定的宽高值    AT_MOST: 对应WRAP_CONTENT  layout流程:   layout(l, t, r, b) --> setFrame(l, t, r, b) --> onLayout(change, l, t, r, b)  draw流程：   ①绘制背景 background.draw(canvas)   ②绘制自己（onDraw）   ③绘制Children(dispatchDraw)   ④绘制装饰（onDrawScrollBars）------------------------------------------------------------------------## Android进程通讯 1. AIDL 2. ContentProvider 3. 全局广播 4. Activity 5. WebSocket 6. Messenger------------------------------------------------------------------------## 5层网络模型 应用层：规定应用程序的数据格式，主要的协议 HTTP，FTP，WebSocket，POP3等； 传输层：建立“端口到端口” 的通信，主要的协议：TCP，UDP； 网络层：建立”主机到主机”的通信，主要的协议：IP，ARP，IP协议的主要作用：一个是为每一台计算机分配IP地址，另一个是确定哪些地址在同一子网； 数据链路层：确定电信号的分组方式，主要的协议：以太网协议； 622，Android进程间通信方式 物理层：负责电信号的传输。------------------------------------------------------------------------## OkHttp3 1. OkHttpClient.Builder 初始化配置 2. val requestBody = new RequestBody 初始化请求方式、参数、ContentType等 3. client.newCall(requestBody).enqueue()异步请求开始    原理分析：    a. OkHttpClient       client.newCall(client, request)最终返回Call对象，它的实现类是RealCall，它传了client对象过去    b. RealCall       newRealCall.enqueue的时候，通过调用client.dispatcher实现异步请求    c. Dispatcher       enqueue的时候，初始化了AsyncCall对象，它继承于NameRunnable。       然后通过asyncCall.executeOn(executorService)去完成请求    d. AsyncCall       从第三步我们可以接收到executorService参数，它是一个线程池       AsyncCall实现了Runnable接口，重写了execute方法。       当executeService.execute(this)的时候，会执行runnable中的execute方法       最终通过getInterceptorResponseChain()实现责任链模式    e. OkHttp的精髓：Interceptor       BridgeInterceptor：主要对 Request 中的 Head 设置默认值，比如 Content-Type、Keep-Alive、Cookie等。       CacheInterceptor：负责 HTTP 请求的缓存处理。       ConnectInterceptor：负责建立与服务器地址之间的连接，也就是 TCP 链接。       CallServerInterceptor：负责向服务器发送请求，并从服务器拿到远端数据结果。    f. 通过getInterceptorResponseChain获取到Response后，使用Callback接口把response回调给用户  4. 设计模式：    建造者模式、门户模式、责任链模式------------------------------------------------------------------------## Rxjava    1. 示例：        Observable           .create(ObservableOnSubscribe<String> {               for (i in 0..2) {                   it.onNext(String.format("事件%s", i))               }           })           .subscribeOn(Schedulers.io())           .observeOn(AndroidSchedulers.mainThread())           .subscribe {               LogUtils.i(it)           }    2. 原理分析     a. Observable        包含subscribeActual方法，是上游和下游产生订阅关系的方法     b. ObservableCreate，继承于Observable        调用create的时候，创建上游ObservableCreate实例，并且初始化ObservableOnSubscribe用于发射数据的接口     c. 创建Observer, 用于接收上游的数据，被称为下游     d. 发生订阅关系subscribe(Observer)        当调用subscribe的时候，通过调用ObservableCreate的subscribeActual方法，执行以下操作：        （1）创建Emitter发射器，parent        （2）下游订阅发射器emitter -- observer.onSubscribe(parent)        （3）上游订阅发射器emitter -- source.subscribe(parent)        其中parent是一个接口，他是发送数据的驱动器。     e. 当用户调用emitter.onNext的时候，下游的onNext马上接收到上游的数据    3. 线程切换 Schedulers.io()        a. 初始化IOTask，它的call方法是调起工作线程的开关，然后调用scheduler = Scheduler.IO，        b. 创建ObservableSubscribeOn，继承于Observable，重写subscribeActual方法        c. 当执行subscribe(observer)时：            首先调用ObservableCreate的subscribeActual方法            再次调用ObservableSubscribeOn的subscribeActual方法，然后发生如下操作:            （1）创建parent = SubscribeOnObserver，用于接收observer的数据            （2）对observer进行包装，observer.onSubscribe(parent)            （3）创建SubscribeTask，它实现了runnable接口，            （4）调用scheduler.scheduleDirect方法，创建管理线程池的Worker: w = createWorker()                w继承于ExecutorService，调用w.schedule(task, delay, unit)之后，                那么成功切换到工作线程去执行上游的事件    4. 线程切换 AndroidSchedulers.mainThread()        a. 创建Handler：Handle-->HandlerScheduler        b. 创建ObservableObserveOn，继承于Observable，重写subscribeActual方法        c. 当执行subscribe(observer)时：            首先调用ObservableCreate的subscribeActual方法            再次调用ObservableSubscribeOn的subscribeActual方法，在工作线程中完成event的处理            最后调用ObservableObserveOn的subscribeActual方法，发生如下操作:             （1）创建HandlerWorker，scheduler.createWorker()，它的schedule方法内部实现了                 handler.sendMessageAtTime的逻辑，也就是说线程是通过它的schedule完成向主线程传递数据             （2）创建ObserveOnObserver，它实现了Observer接口，并且传递了handlerWorker进去             （3）source.subscribe(ObserveOnObserver)，调用父类Observable的subscribe方法，                 通过执行ObserveOnObserver的onNext方法，调用内部的schedule方法，实际上就是调用                 w.schedule, 在第（1）步我们讲到，它内部通过调用handler.sendMessageAtTime完成向主线程抛数据    至此，rxjava普通示例的原理流程全部疏通。------------------------------------------------------------------------ ## 线程池与线程    线程池参数： new ThreadPoolExecutor(corePoolSize, MaximumPoolSize, keepAliveTimes, TimeUnits, workQueues)     1. corePoolSize-- 核心线程数        默认情况下，核心线程会一直存在于线程池，除非调用arrowCoreThreadTimeOut = true，        那么闲置的核心线程将跟其他线程的存活时间一样，到时间将被终止     2. MaximumPoolSize--最大容纳同时执行的线程数        如果任务数量超过最大的线程数量，那么剩下的任务将会阻塞     3. keepAliveTimes, 线程存活时间        闲置线程的超时时间，当arrowCoreThreadTimeOut=true时，闲置的核心线程到超时时间一样被终止     4. TimeUnits， 时间单位        用于指定keepAliveTimes的时间单位，有TimeUnit.SECONDS、TimeUnit.MINUTES、TimeUnit.HOURS、        TimeUnit.DAYS、TimeUnit.MILLISECONDS、TimeUnit.NANOSECONDS     5. workQueue， 任务队列        <1>ArrayBlockingQueue 基于数组实现的有界的阻塞队列        <2>LinkedBlockingQueue 基于链表实现的有界的阻塞队列        <3>SynchronousQueue 内部没有任何容量的阻塞队列        <4>PriorityQueue 具有优先级的无限阻塞队列    线程池的创建     1.单条线程的线程池        Executors.newSingleThreadExecutor()     2.缓存线程池        Executors.newCacheThreadPool()  //     3.定时线程池        Executors.newScheduleThreadPool(threadCount) 支持定时任务及周期性执行     4.固定核心线程数量的线程池        Executors.newFixedThreadPool(threadCount)    线程池的状态     1. RUNNING, 默认状态，接收新的任务并处理队列任务 submit()、execute()     2. SHUTDOWN 不接收新的任务，但处理队列里的任务，shutdown()     3. STOP     不接收新的任务，也不处理队列里的任务，并中断当前执行的任务 shutdownNow()     4. TIDYING  所有的任务都已终止，并运行terminated()方法     4. TERMINATED terminated()方法运行后执行此状态    线程池优点：     1. 可以对线程进行管理     2. 可复用线程，避免频繁new Thread的性能消耗     3. 当执行大量的异步任务时，线程池可以很好的处理--------------------------------------------------------------------- ## Android事件分发机制   以递归的方式实现，分别通过dispatchTouchEvent、interceptTouchEvent、OnTouchEvent这3个方法协助。   每一层View或者viewGroup都包含有这三个方法，这三个方法的关系如下：   1. dispatchTouchEvent      如果返回值是true，那么事件被消费      如果返回值是false，那么事件传递给下一层的onTouchEvent去处理      如果返回值是super，则调用interceptTouchEvent来判断事件是否需要传递   2. interceptTouchEvent      如果返回值是true，事件被拦截，调用本层的onTouchEvent      如果返回值是false/super，那么事件往上一层传递，   3. onTouchEvent      如果返回true，那么事件被消费      如果返回false/super，那么事件从上层往下层传递--------------------------------------------------------------------- ## AIDL   Client、Server、Binder驱动、ServiceManager   client跟server的连接纽带是Stub, Stub继承了Binder，它拥有Binder的transact能力。   但是Stub不跟client打交道，Proxy是Stub内部的一个代理类，它负责与client对接。   1. FragmentTransaction的add和replace的区别？add可以指定到fragment的具体某个生命周期方法吗？   2. 描述一下retrofit的工作原理   3. 描述一下rxjava的工作原理   4. 描述一下线程池的工作原理，它是怎样调起线程的？   5. 假设创建一个10条线程的线程池，有一条线程必须等另外9条线程处理完毕之后才能执行，你会怎么处理？   6. 描述一下Binder的原理   7. 描述一下apk的打包过程，res的文件是怎样打包的？   8. MVP有什么缺点，怎样减少MVP的代码量，MVP运用了哪些设计模式原则？   9. 用过单元测试吗？   10. 用过dagger吗？dagger怎样provide一个实例？   11. startService和bindService的区别