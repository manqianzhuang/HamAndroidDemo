package com.superman.animate.customview.day1import android.annotation.SuppressLintimport android.content.Contextimport android.graphics.Canvasimport android.graphics.Colorimport android.graphics.Paintimport android.util.AttributeSetimport android.view.Viewimport com.blankj.utilcode.util.LogUtilsimport com.superman.animate.Rimport kotlin.math.cosimport kotlin.math.sinclass PiePercentsView(context: Context, attrs: AttributeSet) : View(context, attrs) {    private var paint = Paint(Paint.ANTI_ALIAS_FLAG)    private var data = mutableListOf<PercentData>()    private var total = 0f    private var radius = 400f    //help to draw the middle lines    private var lineLength = 0f    //help to anchoring the textView's coordinate    private var textSkewLength = 0f    //view's width    private var mWidth: Int = 0    //view's height    private var mHeight: Int = 0    //view's middle coordinate    private var centerX = 0f    private var centerY = 0f    private var textSize = 60f    private var textColor: Int = -1    init {        initAttrs(attrs)        setTotal()    }    private fun initAttrs(attrs: AttributeSet) {        val typeArray = context.obtainStyledAttributes(attrs, R.styleable.PiePercentsView)        radius = typeArray.getDimension(R.styleable.PiePercentsView_pieRadius, 400f)        textSize = typeArray.getDimension(R.styleable.PiePercentsView_pieTextSize, 60f)        textColor = typeArray.getColor(R.styleable.PiePercentsView_pieTextColor, Color.BLACK)        lineLength = radius + 40f        textSkewLength = radius + 60f        typeArray.recycle()    }    private fun setTotal() {        data.forEach { total += it.percent }    }    fun setData(data: MutableList<PercentData>) {        this.data = data        setTotal()        invalidate()    }    override fun onDraw(canvas: Canvas?) {        super.onDraw(canvas)        if (data.isEmpty()) return        drawPieTable(canvas)    }    private fun drawPieTable(canvas: Canvas?) {        val sectors = getSectorsData()        sectors.forEach {            paint.color = Color.parseColor(it.color)            //1. draw sector            canvas?.drawArc(                it.left,                it.top,                it.right,                it.bottom,                it.startAngle,                it.sweepAngle,                true,                paint            )            //2. draw lines            canvas?.save()            canvas?.translate(mWidth / 2f, mHeight / 2f)            paint.strokeWidth = 5f            canvas?.drawLine(0f, 0f, it.lineEndX, it.lineEndY, paint)            canvas?.restore()            paint.reset()        }        //3. draw split space        paint.color = Color.WHITE        paint.strokeWidth = 10f        sectors.forEach {            canvas?.save()            canvas?.translate(mWidth / 2f, mHeight / 2f)            canvas?.drawLine(0f, 0f, it.skewingX, it.skewingY, paint)            canvas?.restore()        }        //4. drawText        paint.color = textColor        paint.textSize = textSize        paint.strokeWidth = 15f        sectors.forEach {            canvas?.save()            canvas?.translate(mWidth / 2f, mHeight / 2f)            var x = it.textStartPointX            var y = it.textStartPointY            //The texts in the lower half of the circle all offset down one font height            if (it.middleAngle > 0 && it.middleAngle <= 180) {                y += textSize            }            /**             * Divide the circle into three sections,             * and set the TextAlign direction of the text according to the section.             */            if (it.middleAngle <= -45 || it.middleAngle >= 225 || (it.middleAngle > 45 && it.middleAngle < 135)) {                paint.textAlign = Paint.Align.CENTER            } else if (it.middleAngle > -45 && it.middleAngle <= 45) {                paint.textAlign = Paint.Align.LEFT            } else {                paint.textAlign = Paint.Align.RIGHT            }            canvas?.drawText(it.text, x, y, paint)            canvas?.restore()        }    }    private fun getSectorsData(): MutableList<SectorCoordinate> {        var startAngle = -90f        val sectors = mutableListOf<SectorCoordinate>()        data.forEach {            val sweepAngle = (360 * it.percent / total)            val sector = calculateSectorCoordinate(startAngle, sweepAngle, it.color, it.name)            sectors.add(sector)            startAngle += sweepAngle        }        return sectors    }    override fun onMeasure(widthMeasureSpec: Int, heightMeasureSpec: Int) {        super.onMeasure(widthMeasureSpec, heightMeasureSpec)        // 获取当前view的宽高        mWidth = measuredWidth        mHeight = measuredHeight        // 扇形中心点        centerX = (mWidth / 2).toFloat()        centerY = (mHeight / 2).toFloat()    }    private fun calculateSectorCoordinate(        startAngle: Float,        sweepAngle: Float,        color: String,        text: String    ): SectorCoordinate {        val endAngle = startAngle + sweepAngle        val middleAngle = startAngle + sweepAngle / 2        // 角度转弧度:  π/180×角度 [cos、sin参数是弧度]        val endRadian = endAngle * Math.PI / 180        // 已经斜边和角度: 角度的对边 = 斜边*sin角度  角度邻边 = 斜边*cos角度        val skewingX = (radius * cos(endRadian)).toFloat()        val skewingY = (radius * sin(endRadian)).toFloat()        val middleRadian = middleAngle * Math.PI / 180        val lineEndX = (lineLength * cos(middleRadian)).toFloat()        val lineEndY = (lineLength * sin(middleRadian)).toFloat()        val textStartPointX = (textSkewLength * cos(middleRadian)).toFloat()        val textStartPointY = (textSkewLength * sin(middleRadian)).toFloat()        LogUtils.e("扇形点： $skewingX, $skewingY")        val left = centerX - radius        val top = centerY - radius        val right = centerX + radius        val bottom = centerY + radius        return SectorCoordinate(            middleAngle = middleAngle,            startAngle = startAngle,            sweepAngle = sweepAngle,            left = left,            top = top,            right = right,            bottom = bottom,            skewingX = skewingX,            skewingY = skewingY,            lineEndX = lineEndX,            lineEndY = lineEndY,            textStartPointX = textStartPointX,            textStartPointY = textStartPointY,            color = color,            text = text        )    }    /**     * record the sector attribute     */    private data class SectorCoordinate(        var middleAngle: Float, //        var startAngle: Float,  //开始角度        var sweepAngle: Float,  //偏移角度        var left: Float,        //        var top: Float,        var right: Float,        var bottom: Float,        var skewingX: Float,        var skewingY: Float,        var lineEndX: Float,        var lineEndY: Float,        var textStartPointX: Float,        var textStartPointY: Float,        var color: String,        var text: String,    )    data class PercentData(        var percent: Float,        var name: String,        var color: String,    )}